<?xml version="1.0" encoding="UTF-8"?>
<!-- Copyright (c) 2012-2017 The Etnaviv Project

 Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation
 the rights to use, copy, modify, merge, publish, distribute, sub license,
 and/or sell copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial portions
 of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.
-->
<database xmlns="http://nouveau.freedesktop.org/"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://nouveau.freedesktop.org/ rules-ng.xsd">

<import file="copyright.xml"/>

<!-- Vivante GCxxxx render states and registers overview:
     PIPE_3D (3D rendering) state. Based on reverse engineering, guesswork and experimentation.
  -->
<domain name="VIVS" brief="GPU state">
    <enum name="COMPARE_FUNC" brief="Compare function (for glStencilFunc and glDepthFunc)">
        <!-- Either a coincidence or due to shared roots in DirectX: same enum as Gallium3D PIPE_FUNC
             Commented out because name conflicts with "enum compare_func" in mesa (values identical too)
        <value value="0" name="NEVER"/>
        <value value="1" name="LESS"/>
        <value value="2" name="EQUAL"/>
        <value value="3" name="LEQUAL"/>
        <value value="4" name="GREATER"/>
        <value value="5" name="NOTEQUAL"/>
        <value value="6" name="GEQUAL"/>
        <value value="7" name="ALWAYS"/>
        -->
    </enum>
    <enum name="STENCIL_OP" brief="Stencil operation">
        <value value="0" name="KEEP" brief="Keeps the current value"/>
        <value value="1" name="ZERO" brief="Sets the stencil buffer value to 0"/>
        <value value="2" name="REPLACE" brief="Sets the stencil value to ref"/>
        <value value="3" name="INCR" brief="Increments stencil buffer value, clamps to max"/>
        <value value="4" name="DECR" brief="Descrements stencil buffer value, clamps to min"/>
        <value value="5" name="INVERT" brief="Bitwise inverts the current stencil buffer value"/>
        <value value="6" name="INCR_WRAP" brief="Increments stencil buffer value, wraps around"/>
        <value value="7" name="DECR_WRAP" brief="Decrements stencil buffer value, wraps around"/>
    </enum>
    <enum name="BLEND_EQ" brief="Blend equation">
        <doc>determines how pixel blending combines source and destination</doc>
        <value value="0" name="ADD"/>
        <value value="1" name="SUBTRACT"/>
        <value value="2" name="REVERSE_SUBTRACT"/>
        <value value="3" name="MIN"/>
        <value value="4" name="MAX"/>
    </enum>
    <enum name="BLEND_FUNC" brief="glBlendFunc">
        <value value="0" name="ZERO"/>
        <value value="1" name="ONE"/>
        <value value="2" name="SRC_COLOR"/>
        <value value="3" name="ONE_MINUS_SRC_COLOR"/>
        <value value="4" name="SRC_ALPHA"/>
        <value value="5" name="ONE_MINUS_SRC_ALPHA"/>
        <value value="6" name="DST_ALPHA"/>
        <value value="7" name="ONE_MINUS_DST_ALPHA"/>
        <value value="8" name="DST_COLOR"/>
        <value value="9" name="ONE_MINUS_DST_COLOR"/>
        <value value="10" name="SRC_ALPHA_SATURATE"/>
        <value value="11" name="CONSTANT_ALPHA"/>
        <value value="12" name="ONE_MINUS_CONSTANT_ALPHA"/>
        <value value="13" name="CONSTANT_COLOR"/>
        <value value="14" name="ONE_MINUS_CONSTANT_COLOR"/>
    </enum>
    <enum name="RS_FORMAT" brief="Resolve pixel format">
        <value value="0" name="X4R4G4B4"/>
        <value value="1" name="A4R4G4B4"/>
        <value value="2" name="X1R5G5B5"/>
        <value value="3" name="A1R5G5B5"/>
        <value value="4" name="R5G6B5"/>
        <value value="5" name="X8R8G8B8"/>
        <value value="6" name="A8R8G8B8"/>
        <value value="7" name="YUY2"/><!-- only supported with YUY2_AVERAGING -->
        <value value="21" name="64BPP_CLEAR"/><!-- HALTI2 -->
    </enum>
    <enum name="PE_FORMAT" brief="Render pixel format">
        <value value="0" name="X4R4G4B4"/>
        <value value="1" name="A4R4G4B4"/>
        <value value="2" name="X1R5G5B5"/>
        <value value="3" name="A1R5G5B5"/>
        <value value="4" name="R5G6B5"/>
        <value value="5" name="X8R8G8B8"/>
        <value value="6" name="A8R8G8B8"/>
        <value value="7" name="YUY2"/><!-- only supported with YUY2_AVERAGING -->
        <!-- 8..15 do show color and don't result in GPU crashes directly, also they don't
             seem to be direct aliases of 0..7, but it needs to be figured out if
             they're useful or just alternative names for formats in range 0..7
         -->
        <!-- Extended formats -->
        <value value="16" name="A8"/> <!-- GC7000 -->
        <value value="17" name="R16F"/>
        <value value="18" name="G16R16F" brief="Also used for X16R16F"/>
        <value value="19" name="A16B16G16R16F" brief="Also used for X16B16G16R16F"/>
        <value value="20" name="R32F" brief="Also used for R32I R32UI"/>
        <value value="21" name="G32R32F" brief="Also used for X32R32F G32R32UI"/>
        <value value="22" name="A2B10G10R10" brief="Also used for X2B10G10R10"/>
        <value value="23" name="R8I" brief="Also used for R8UI"/>
        <value value="24" name="G8R8I" brief="Also used for X8R8I X8R8UI G8R8UI"/>
        <value value="25" name="A8B8G8R8I" brief="Also used for X8B8G8R8I X8B8G8R8UI A8B8G8R8UI"/>
        <value value="26" name="R16I" brief="Also used for R16UI"/>
        <value value="27" name="G16R16I" brief="Also used for X16R16I X16R16UI G16R16UI"/>
        <value value="28" name="A16B16G16R16I" brief="Also used for X16B16G16R16I X16B16G16R16UI A16B16G16R16UI"/>
        <value value="29" name="B10G11R11F"/>
        <value value="30" name="A2B10G10R10UI"/>
        <value value="31" name="G8R8"/>
        <value value="35" name="R8"/> <!-- GC7000 -->
    </enum>
    <enum name="LOGIC_OP" brief="LogicOp">
        <value value="0" name="CLEAR"/>
        <value value="1" name="NOR"/>
        <value value="2" name="AND_INVERTED"/>
        <value value="3" name="COPY_INVERTED"/>
        <value value="4" name="AND_REVERSE"/>
        <value value="5" name="INVERT"/>
        <value value="6" name="XOR"/>
        <value value="7" name="NAND"/>
        <value value="8" name="AND"/>
        <value value="9" name="EQUIV"/>
        <value value="10" name="NOOP"/>
        <value value="11" name="OR_INVERTED"/>
        <value value="12" name="COPY"/> <!-- Default -->
        <value value="13" name="OR_REVERSE"/>
        <value value="14" name="OR"/>
        <value value="15" name="SET"/>
    </enum>
    <enum name="COLOR_OUTPUT_MODE">
        <value value="0" name="NORMAL"/>
        <!-- these values seem to bypass blend, which only works with 16-bit and no integers
             -with value 0, only 16 incorrect LSBs are written in the output channels
             -not sure what is actually different between these values, since PE format
              should contain this information??
        -->
        <value value="1" name="A2B10G10R10UI"/>
        <value value="2" name="UIF32"/>
        <value value="3" name="U8"/>
        <value value="4" name="U16"/>
        <value value="5" name="I8"/>
        <value value="6" name="I16"/>
    </enum>

    <bitset name="VARYING_NUM_COMPONENTS">
        <bitfield high="2" low="0" name="VAR0"/>
        <bitfield high="6" low="4" name="VAR1"/>
        <bitfield high="10" low="8" name="VAR2"/>
        <bitfield high="14" low="12" name="VAR3"/>
        <bitfield high="18" low="16" name="VAR4"/>
        <bitfield high="22" low="20" name="VAR5"/>
        <bitfield high="26" low="24" name="VAR6"/>
        <bitfield high="30" low="28" name="VAR7"/>
    </bitset>

    <stripe name="VS" brief="Vertex shader states">
        <doc>The vertex shader to be used for 3D rendering is configured here.</doc>
        <reg32 offset="0x00800" name="END_PC" value="0x00000000" brief="End instruction number">
            <doc>index of last instruction + 1</doc>
        </reg32>
        <reg32 offset="0x00804" name="OUTPUT_COUNT" value="0x00000000" type="uint" brief="Number of VS outputs"/>
        <reg32 offset="0x00808" name="INPUT_COUNT" value="0x00000000">
            <bitfield high="3" low="0" name="COUNT" type="uint" brief="Number of VS inputs"/>
            <bitfield high="12" low="8" name="UNK8" type="uint"/>
            <bitfield pos="31" name="ID_ENABLE"/> <!-- last input contains vertex/instance ids -->
        </reg32>
        <reg32 offset="0x0080C" name="TEMP_REGISTER_CONTROL" brief="Temporary register control" value="0x00000000">
            <bitfield high="5" low="0" name="NUM_TEMPS" type="uint" brief="Number of temporary registers"/>
        </reg32>
        <reg32 offset="0x00810" name="OUTPUT" value="0x00000000" brief="Output routing" length="4" stride="4"> <!-- !HALTI5 -->
            <doc>
                Each bitfield (up to 16 in total) contains a temporary register number that
                is used as output at the end of the shader for that varying.
            </doc>
            <bitfield high="7" low="0" name="O0" type="uint"/>
            <bitfield high="15" low="8" name="O1" type="uint"/>
            <bitfield high="23" low="16" name="O2" type="uint"/>
            <bitfield high="31" low="24" name="O3" type="uint"/>
        </reg32>
        <reg32 offset="0x00820" name="INPUT" value="0x00000000" brief="Input routing" length="4" stride="4"> <!-- !HALTI5 -->
            <doc>
                Each bitfield (up to 16 in total) contains the number of a temporary register that
                is assigned the input for that attribute at the beginning of shader execution.
            </doc>
            <bitfield high="7" low="0" name="I0" type="uint"/>
            <bitfield high="15" low="8" name="I1" type="uint"/>
            <bitfield high="23" low="16" name="I2" type="uint"/>
            <bitfield high="31" low="24" name="I3" type="uint"/>
        </reg32>
        <reg32 offset="0x00830" name="LOAD_BALANCING" value="0x00000000">
            <bitfield high="7" low="0" name="A"/>
            <bitfield high="15" low="8" name="B"/>
            <bitfield high="23" low="16" name="C"/>
            <bitfield high="31" low="24" name="D"/>
        </reg32>
        <reg32 offset="0x00834" name="PERF_COUNTER" brief="Performance counter control"/>
        <reg32 offset="0x00838" name="START_PC" value="0x00000000"/>
        <reg32 offset="0x00850" name="UNK00850" value="0x000003e8"/>
        <reg32 offset="0x00854" name="UNK00854" value="0x00000100"/>
        <reg32 offset="0x00858" name="UNK00858" value="0x00001005"/>
        <reg32 offset="0x0085C" name="RANGE" value="0x00000000" brief="Defines the range within which VS instructions are executed, relative to start of the state area"> <!-- instructionCount > 1024 -->
            <bitfield high="15" low="0" name="LOW" brief="Index of first VS instruction"/>
            <bitfield high="31" low="16" name="HIGH" brief="Index of last VS instruction"/>
        </reg32>
        <!-- The following register is set to the Vivante driver to:
             - Rendering on GC2000:
               - 0x00000000  Before loading VS uniform / code
               - 0x00000011  Before loading PS uniform / code
             - Rendering on GC3000:
               - 0x00000001  Before loading VS uniform
               - 0x00000000  Before loading VS code
               - 0x00000011  Before loading PS uniform / code
             - OpenCL on GC2000: always 0x0
             - OpenCL on GC3000: always 0x1011

             It controls flushing cached uniforms, in combination with unified SH_UNIFORMS.

             Vivante kernel driver calls this "DECODE_SELECT", and selects the destination for unified uniform and
             shader code loads.
         -->
        <reg32 offset="0x00860" name="UNIFORM_CACHE" value="0x00000000"> <!-- instructionCount > 1024, !HALTI5 -->
            <bitfield pos="0" name="FLUSH"/>
            <bitfield pos="4" name="PS" brief="0 for VS, 1 for PS"/>
            <bitfield pos="12" name="RTNE_ROUNDING"/> <!-- HALTI5 has this bit in state 0x15600 -->
        </reg32>
        <!-- The following is used with unified uniforms (SH_UNIFORM_*) -->
        <reg32 offset="0x00864" name="UNIFORM_BASE" brief="Offset applied to VS uniform loads (granularity is 4-vectors)"/>
        <!-- ICACHE is a new feature in GC3000 on i.MX6qp where the shader code
             is stored in memory instead
             of having to be loaded into a range of states.
             The Vivante driver (as of 5.0.11.p8.4) only uses this for:

             - OpenCL compute - always
             - When a shader is too large to fit into the assigned state area

             It is unclear what the rationale is to not always use it: either stability
             or performance.

             Setting it up:
               - ICACHE_CONTROL := ENABLE | FLUSH_VS
               - VS.INST_ADDR := <GPU address>
               - ICACHE_CONTROL := ENABLE | FLUSH_PS
               - PS.INST_ADDR := <GPU address>

             ICACHE invalidate (from kernel driver):

               [0x860]=0
               [0x868]=0x11
               [0x860]=1
               [0x868]=0x21
          -->
        <reg32 offset="0x00868" name="ICACHE_CONTROL"> <!-- ICACHE -->
            <bitfield pos="0" name="ENABLE" brief="Enables loading of shader instructions from memory"/>
            <!-- "flush" guess is based on the Vivante driver behavior where
                 these bits are only being set before setting instruction address
             -->
            <bitfield pos="4" name="FLUSH_VS"/>
            <bitfield pos="5" name="FLUSH_PS"/>
        </reg32>
        <reg32 offset="0x0086C" name="INST_ADDR" type="VIVM" brief="Memory address of shader instructions, must be aligned to 0x100"/> <!-- ICACHE -->
        <reg32 offset="0x00870" name="HALTI5_OUTPUT_COUNT"> <!-- HALTI5 -->
            <bitfield high="9" low="0" name="COUNT"/> <!-- Same as VS.OUTPUT_COUNT -->
	    <bitfield high="18" low="8" name="B"/> <!-- = COUNT*0x10 -->
	</reg32>
        <!-- "new shader instruction PC registers (20 bit)" -->
        <reg32 offset="0x00874" name="NEWRANGE_LOW"/> <!-- HALTI5 || ICACHE -->
        <reg32 offset="0x00878" name="HALTI5_UNK00878"/> <!-- !HALTI5 && ICACHE "VS/PS Start/End PC register" -->
        <reg32 offset="0x00880" name="HALTI5_UNK00880"/> <!-- !HALTI5 && ICACHE "VS/PS Start/End PC register" -->
        <reg32 offset="0x00884" name="HALTI1_UNK00884"/> <!-- HALTI1 -->
        <reg32 offset="0x0088C" name="ICACHE_PREFETCH" brief="Trigger icache prefetch"/>
        <reg32 offset="0x00890" name="ICACHE_UNK00890"/> <!-- !HALTI5 && ICACHE_PREFETCH -->
        <reg32 offset="0x00898" name="HALTI5_UNK00898" length="2" stride="4"/> <!-- HALTI5 -->
        <reg32 offset="0x008A0" name="HALTI5_UNK008A0"> <!-- HALTI5 -->
            <!-- Various tweaking parameters regarding VS outputs? -->
            <bitfield high="5" low="0" name="A"/> <!-- 0xe -->
            <bitfield high="18" low="12" name="B"/> <!-- 0x10 -->
            <bitfield high="28" low="20" name="C"/> <!-- 0x110 / output_count -->
	</reg32>
        <reg32 offset="0x008A8" name="SAMPLER_BASE" brief="Offset value applied to sampler index from VS"/> <!-- HALTI5 -->
        <reg32 offset="0x008B0" name="ICACHE_INVALIDATE"> <!-- HALTI5 -->
            <doc>Kernel driver writes value with all 5 bits set to here to flush ICACHE.</doc>
            <bitfield pos="0" name="UNK0"/>
            <bitfield pos="1" name="UNK1"/>
            <bitfield pos="2" name="UNK2"/>
            <bitfield pos="3" name="UNK3"/>
            <bitfield pos="4" name="UNK4"/>
        </reg32>
        <reg32 offset="0x008B8" name="HALTI5_UNK008B8"/> <!-- HALTI5 -->
        <reg32 offset="0x008BC" name="NEWRANGE_HIGH"/> <!-- HALTI5 -->
        <reg32 offset="0x008C0" name="HALTI5_INPUT" length="8" stride="4"> <!-- HALTI5 -->
            <!-- See VS.INPUT for description of fields -->
            <bitfield high="7" low="0" name="I0" type="uint"/>
            <bitfield high="15" low="8" name="I1" type="uint"/>
            <bitfield high="23" low="16" name="I2" type="uint"/>
            <bitfield high="31" low="24" name="I3" type="uint"/>
        </reg32>
        <reg32 offset="0x008E0" name="HALTI5_OUTPUT" length="8" stride="4"> <!-- HALTI5 -->
            <!-- See VS.OUTPUT for description of fields -->
            <bitfield high="7" low="0" name="O0" type="uint"/>
            <bitfield high="15" low="8" name="O1" type="uint"/>
            <bitfield high="23" low="16" name="O2" type="uint"/>
            <bitfield high="31" low="24" name="O3" type="uint"/>
        </reg32>
        <reg32 offset="0x04000" name="INST_MEM" value="0x00000000" length="1024" stride="4"> <!-- instructionCount <= 256 -->
            <!-- length="instructionCount * 4" -->
        </reg32>
        <reg32 offset="0x05000" name="UNIFORMS" value="0x00000000" length="1024" stride="4">
            <!-- length="vertexUniforms * 4" -->
        </reg32>
        <!-- same as 0x01094 for PS -->
        <reg32 offset="0x15604" name="ICACHE_COUNT" brief="Number of instructions minus one"/> <!-- HALTI5 && ICACHE_PREFETCH -->
    </stripe>

    <bitset name="CL_GLOBAL_DIM" inline="yes">
        <bitfield high="15" low="0" name="SIZE"/>
        <bitfield high="31" low="16" name="OFFSET"/>
    </bitset>
    <bitset name="CL_WORKGROUP_DIM" inline="yes">
        <bitfield high="9" low="0" name="SIZE" brief="Size of work group minus one"/>
        <bitfield high="31" low="16" name="COUNT" brief="Number of work groups minus one"/>
    </bitset>
    <stripe name="CL" brief="Thread walker states">
        <doc>The thread walker drives shaders in a predefined grid for GPGPU computing (OpenCL).
        These states are not used for normal rendering.</doc>
        <reg32 offset="0x00900" name="CONFIG" value="0x00000000">
            <bitfield high="1" low="0" name="DIMENSIONS" brief="Number of dimensions (1-3)"/>
            <bitfield high="6" low="4" name="TRAVERSE_ORDER"/>
            <bitfield high="8" low="8" name="ENABLE_SWATH_X"/>
            <bitfield high="9" low="9" name="ENABLE_SWATH_Y"/>
            <bitfield high="10" low="10" name="ENABLE_SWATH_Z"/>
            <bitfield high="15" low="12" name="SWATH_SIZE_X"/>
            <bitfield high="19" low="16" name="SWATH_SIZE_Y"/>
            <bitfield high="23" low="20" name="SWATH_SIZE_Z"/>
            <bitfield high="26" low="24" name="VALUE_ORDER" brief="Order in which global/group/local ids are in temp registers">
                <doc>At the beginning of a thread the first temporary registers will contain the local work id (L), work group id (W) and global work id (G).

                    For following usage/orderings the blob uses these values:
                        L = 0x5
                        W = 0x4
                        G = 0x3
                        L | W = 0x0
                        W | L = 0x1
                        G | W = 0x2
                        G | L = 0x3
                        W | G = 0x4
                        L | G = 0x5

                    It should be possible to use e.g 0x0 for L only ,0x1 for W only and 0x2 for G only.
                </doc>
            </bitfield>
        </reg32>
        <reg32 offset="0x00904" name="GLOBAL_X" type="CL_GLOBAL_DIM" value="0x00000000"/>
        <reg32 offset="0x00908" name="GLOBAL_Y" type="CL_GLOBAL_DIM" value="0x00000000"/>
        <reg32 offset="0x0090C" name="GLOBAL_Z" type="CL_GLOBAL_DIM" value="0x00000000"/>
        <reg32 offset="0x00910" name="WORKGROUP_X" type="CL_WORKGROUP_DIM" value="0x00000000"/>
        <reg32 offset="0x00914" name="WORKGROUP_Y" type="CL_WORKGROUP_DIM" value="0x00000000"/>
        <reg32 offset="0x00918" name="WORKGROUP_Z" type="CL_WORKGROUP_DIM" value="0x00000000"/>
        <reg32 offset="0x0091C" name="THREAD_ALLOCATION" value="0x00000000"/>
        <reg32 offset="0x00920" name="KICKER" brief="Start thread walker">
            <doc>Write some value to this register to kick off thread walker</doc>
        </reg32>
        <reg32 offset="0x00924" name="UNK00924" value="0x00000000"/>
        <reg32 offset="0x0092C" name="GLOBAL_WORK_OFFSET_X" value="0x00000000"/>
        <reg32 offset="0x00934" name="GLOBAL_WORK_OFFSET_Y" value="0x00000000"/>
        <reg32 offset="0x0093C" name="GLOBAL_WORK_OFFSET_Z" value="0x00000000"/>
        <reg32 offset="0x00940" name="WORKGROUP_COUNT_X" value="0x00000000"/> <!-- SHADER_ENHANCEMENTS2 -->
        <reg32 offset="0x00944" name="WORKGROUP_COUNT_Y" value="0x00000000"/> <!-- SHADER_ENHANCEMENTS2 -->
        <reg32 offset="0x00948" name="WORKGROUP_COUNT_Z" value="0x00000000"/> <!-- SHADER_ENHANCEMENTS2 -->

        <reg32 offset="0x0094C" name="WORKGROUP_SIZE_X" value="0x00000000"> <!-- SHADER_ENHANCEMENTS2 -->
            <doc>Set to workgroup size x - 1</doc>
        </reg32>
        <reg32 offset="0x00950" name="WORKGROUP_SIZE_Y" value="0x00000000"> <!-- SHADER_ENHANCEMENTS2 -->
            <doc>Set to workgroup size y - 1</doc>
        </reg32>
        <reg32 offset="0x00954" name="WORKGROUP_SIZE_Z" value="0x00000000"> <!-- SHADER_ENHANCEMENTS2 -->
            <doc>Set to workgroup size z - 1</doc>
        </reg32>

        <reg32 offset="0x00958" name="HALTI5_UNK00958"/> <!-- HALTI5 -->
        <reg32 offset="0x0095C" name="HALTI5_UNK0095C"/> <!-- HALTI5 -->
        <reg32 offset="0x00960" name="HALTI5_UNK00960"/> <!-- HALTI5 -->
    </stripe>

    <stripe name="PA" brief="Primitive assembly states">
        <doc>Primitive assembly assembles primitives (tris, quads, lines, points etc) from vertices for 3D rendering.
            Viewport scaling, line width and point size is configured here.</doc>
        <reg32 offset="0x00A00" name="VIEWPORT_SCALE_X" value="0x00000000" type="float"/>
        <reg32 offset="0x00A04" name="VIEWPORT_SCALE_Y" value="0x00000000" type="float"/>
        <reg32 offset="0x00A08" name="VIEWPORT_SCALE_Z" value="0x00000000" type="float"/>
        <reg32 offset="0x00A0C" name="VIEWPORT_OFFSET_X" value="0x00000000" type="float"/>
        <reg32 offset="0x00A10" name="VIEWPORT_OFFSET_Y" value="0x00000000" type="float"/>
        <reg32 offset="0x00A14" name="VIEWPORT_OFFSET_Z" value="0x00000000" type="float"/>
        <reg32 offset="0x00A18" name="LINE_WIDTH" value="0x00000000" type="float" brief="Half of line width in pixels"/>
        <reg32 offset="0x00A1C" name="POINT_SIZE" value="0x00000000" type="float"/>
        <reg32 offset="0x00A24" name="UNK00A24"/> <!-- GC400 dummy draw -->
        <reg32 offset="0x00A28" name="SYSTEM_MODE" value="0x00000000"> <!-- D3D/OpenGL switch -->
            <doc>0x11 for OpenGL, 0x00 for D3D9</doc>
            <bitfield pos="0" name="PROVOKING_VERTEX_LAST"/>
            <bitfield pos="4" name="HALF_PIXEL_CENTER"/>
        </reg32>
        <reg32 offset="0x00A2C" name="W_CLIP_LIMIT" value="0x00000000"/>
        <reg32 offset="0x00A30" name="ATTRIBUTE_ELEMENT_COUNT" value="0x00000000">
            <bitfield high="7" low="0" name="UNK0"/>
            <bitfield high="15" low="8" name="COUNT"/>
        </reg32>
        <reg32 offset="0x00A34" name="CONFIG" value="0x00000000" brief="Primitive assembly state flags">
            <doc>
            These can be set either per group of bits, or all at once, by using masking flags.
            Each group of state flags has a masking flag that prevents overwriting the flags in that group.
            </doc>
            <bitfield pos="2" name="POINT_SIZE_ENABLE" brief="Enable point size">
                <doc>Adds an extra output to VS (at the end).</doc>
            </bitfield>
            <bitfield pos="3" name="POINT_SIZE_ENABLE_MASK"/>
            <bitfield pos="4" name="POINT_SPRITE_ENABLE" brief="Enable point sprite"/>
            <bitfield pos="5" name="POINT_SPRITE_ENABLE_MASK"/>
            <bitfield high="9" low="8" name="CULL_FACE_MODE">
                <value value="0" name="OFF" brief="Disable face culling"/>
                <value value="1" name="CW" brief="Orientation of front-facing polygons is clockwise"/>
                <value value="2" name="CCW" brief="Orientation of front-facing polygons is counter-clockwise"/>
            </bitfield>
            <bitfield pos="10" name="CULL_FACE_MODE_MASK"/>
            <bitfield high="13" low="12" name="FILL_MODE">
                <value value="0" name="POINT"/>
                <value value="1" name="WIREFRAME"/>
                <value value="2" name="SOLID"/>
            </bitfield>
            <bitfield pos="14" name="FILL_MODE_MASK"/>
            <bitfield high="17" low="16" name="SHADE_MODEL">
                <value value="0" name="FLAT" brief="Flat shading"/>
                <value value="1" name="SMOOTH" brief="Gouraud shading"/>
            </bitfield>
            <bitfield pos="18" name="SHADE_MODEL_MASK"/>
            <bitfield pos="22" name="WIDE_LINE"/> <!-- MUST be set when drawing lines when WIDE_LINE feature available, otherwise GC3000+ will not render lines at all -->
            <bitfield pos="23" name="WIDE_LINE_MASK"/>
        </reg32>
        <reg32 offset="0x00A38" name="WIDE_LINE_WIDTH0" value="0x00000000" type="float" brief="Line width, used when PA.CONFIG.WIDE_LINE set"/>
        <reg32 offset="0x00A3C" name="WIDE_LINE_WIDTH1" value="0x00000000" type="float" brief="Another line width, used when PA.CONFIG.WIDE_LINE set"/>
        <reg32 offset="0x00A40" name="SHADER_ATTRIBUTES" value="0x00000000" length="10" stride="4"> <!-- !HALTI5 -->
            <doc>Flags word per shader attribute. I suspect that these determine the type of interpolation
                (color, perspective, linear, ...).</doc>
            <bitfield high="0" low="0" name="BYPASS_FLAT" brief="Bypass flat shading for this varying"/>
            <bitfield high="7" low="4" name="UNK4"/>
            <bitfield high="11" low="8" name="UNK8"/>
        </reg32>
        <reg32 offset="0x00A80" name="VIEWPORT_UNK00A80" value="0x00000000" type="float">
            <doc>
            Blob sets this based on size of the viewport or render target
            256 x 256   -> 1.526625e-05 ~= 1/65504
            1920 x 1080 -> 1.144968e-04 ~= 1/8734
            Works out to 5.96337734375e-08 * width.
            I have not yet found any visual indication of what it does.
            </doc>
        </reg32>
        <reg32 offset="0x00A84" name="VIEWPORT_UNK00A84" value="0x00000000" type="float"> <!-- GC3000: This affects point sprite rendering, blob sets this to 8192.0 -->
            <doc>
            I found that lower values than 8192 scale the point size down.
            </doc>
        </reg32>
        <reg32 offset="0x00A88" name="FLAGS">
            <doc>
                The Vivante driver sets these at context setup, they seem to be
                some global bypasses and CYA flags.
            </doc>
            <bitfield pos="24" name="UNK24"/> <!-- set on gc2000 -->
            <!-- Below state basically breaks the Z buffer when enabled in Mesa driver -
                 should be coupled with a change in shaders.
             -->
            <bitfield pos="30" name="ZCONVERT_BYPASS"/> <!-- set on gc3000 and gc7000 -->
        </reg32>
        <reg32 offset="0x00A8C" name="ZFARCLIPPING" value="0x00000000">
            <doc>
                This is set by the Vivante driver to 0x00000000 if the
                chipMinorFeatures4_ZFIXES bit is set (as on gc3000), 0x38000000
                otherwise (gc2000).
            </doc>
	</reg32>
        <!-- Looks like the blob writes the same values here as to 01080+x, at least in
             many cases. Might be varying num components (which used to be in GL).
         -->
        <reg32 offset="0x00A90" name="VARYING_NUM_COMPONENTS" type="VARYING_NUM_COMPONENTS" length="4" stride="4"/> <!-- HALTI5 -->
        <reg32 offset="0x00AA8" name="VS_OUTPUT_COUNT" brief="Looks like a duplicate of VS output count"/> <!-- HALTI5 -->
    </stripe>

    <stripe name="SE" brief="Setup Engine states">
        <doc>The setup engine takes care of scissor, clipping, and depth scale.</doc>
        <reg32 offset="0x00C00" name="SCISSOR_LEFT" value="0x00000000" type="float"/>
        <reg32 offset="0x00C04" name="SCISSOR_TOP" value="0x00000000" type="float"/>
        <reg32 offset="0x00C08" name="SCISSOR_RIGHT" value="0x45000000" type="float"/>
        <reg32 offset="0x00C0C" name="SCISSOR_BOTTOM" value="0x45000000" type="float"/>
        <reg32 offset="0x00C10" name="DEPTH_SCALE" value="0x00000000" type="float" brief="Depth scale"/>
        <reg32 offset="0x00C14" name="DEPTH_BIAS" value="0x00000000" type="float" brief="Depth bias (divided by 65535)"/>
        <reg32 offset="0x00C18" name="CONFIG" value="0x00000000">
            <bitfield pos="0" name="LAST_PIXEL_ENABLE" brief="Render last pixel of line">
                <doc>Always disabled for OpenGL</doc>
            </bitfield>
        </reg32>
        <reg32 offset="0x00C1C" name="UNK00C1C" value="0x42000000"/>
        <reg32 offset="0x00C20" name="CLIP_RIGHT" value="0x00000000" type="float"/>
        <reg32 offset="0x00C24" name="CLIP_BOTTOM" value="0x00000000" type="float"/>
    </stripe>

    <stripe name="RA" brief="Raster states">
        <doc>Configuration for the rasterizer. This mainly controls multisampling.</doc>
        <reg32 offset="0x00E00" name="CONTROL" value="0x000000F1">
            <bitfield pos="0" name="UNK0"/>
            <bitfield pos="1" name="LAST_VARYING_2X" brief="Last varying has 1 or 2 components"></bitfield>
        </reg32>
        <reg32 offset="0x00E04" name="MULTISAMPLE_UNK00E04" value="0x00000000"/>
        <reg32 offset="0x00E08" name="EARLY_DEPTH" value="0x17000031" brief="Early depth control">
            <bitfield pos="0" name="TEST_ENABLE"/>
            <bitfield pos="24" name="HDEPTH_DISABLE"/>
                <doc>HDEPTH can only be used when early testing is enabled and depth is written from the RA stage.</doc>
            <bitfield pos="25" name="LATE_DEPTH_MSAA"/>
            <bitfield pos="28" name="WRITE_DISABLE"/>
        </reg32>
        <reg32 offset="0x00E0C" name="UNK00E0C" value="0x00000000"/> <!-- HALTI2 -->
        <reg32 offset="0x00E10" name="MULTISAMPLE_UNK00E10" value="0x00000000" length="4" stride="4"/>
        <reg32 offset="0x00E20" name="HDEPTH_CONTROL">
            <bitfield pos="0" name="UNK0"/>
            <bitfield high="14" low="12" name="COMPARE" type="COMPARE_FUNC"/>
        </reg32>
        <reg32 offset="0x00E24" name="UNK00E24"/>
        <reg32 offset="0x00E34" name="HALTI5_UNK00E34"/> <!-- HALTI5 -->
        <reg32 offset="0x00E40" name="CENTROID_TABLE" value="0x00000000" length="16" stride="4"/>
    </stripe>

    <stripe name="PS" brief="Pixel Shader states">
        <doc>The Pixel (Fragment) shader to use is configured here</doc>
        <reg32 offset="0x01000" name="END_PC" value="0x00000000"/>
        <reg32 offset="0x01004" name="OUTPUT_REG" value="0x00000000" brief="Register that will contain output color"/>
        <reg32 offset="0x01008" name="INPUT_COUNT" value="0x00000000">
            <bitfield high="3" low="0" name="COUNT" type="uint" brief="Number of PS inputs"/>
            <bitfield high="12" low="8" name="UNK8" type="uint"/>
            <bitfield pos="16" name="DUAL16" brief="Enable dual-16 mode for PS"/>
        </reg32>
        <reg32 offset="0x0100C" name="TEMP_REGISTER_CONTROL" brief="Temporary register control" value="0x00000000">
            <bitfield high="5" low="0" name="NUM_TEMPS" type="uint" brief="Number of temporary registers"/>
        </reg32>
        <reg32 offset="0x01010" name="CONTROL" value="0x00000000">
            <bitfield pos="0" name="BYPASS"/>
            <bitfield pos="1" name="SATURATE_RT0"/> <!-- enable for unorm formats -->
            <bitfield pos="2" name="SATURATE_RT1"/>
            <bitfield pos="3" name="SATURATE_RT2"/>
            <bitfield pos="4" name="SATURATE_RT3"/>
            <bitfield high="10" low="8" name="RT_COUNT"/> <!-- number of render targets minus one -->
        </reg32>
        <reg32 offset="0x01014" name="PERF_COUNTER" brief="Performance counter control"/>
        <reg32 offset="0x01018" name="START_PC" value="0x01000000"/>
        <reg32 offset="0x0101C" name="RANGE" value="0x00000100" brief="Defines the range within which PS instructions are executed, relative to start of the state area"> <!-- instructionCount > 1024 -->
            <bitfield high="15" low="0" name="LOW" brief="Index of first PS instruction"/>
            <bitfield high="31" low="16" name="HIGH" brief="Index of last PS instruction"/>
        </reg32>
        <reg32 offset="0x0101E" name="REG_COUNT"/>
        <!-- The following is used with unified uniforms (SH_UNIFORM_*) -->
        <reg32 offset="0x01024" name="UNIFORM_BASE" brief="Offset applied to PS uniform loads (granularity is 4-vectors)"/> <!-- -->
        <reg32 offset="0x01028" name="INST_ADDR" type="VIVM" brief="Memory address of shader instructions, must be aligned to 0x100"/> <!-- ICACHE -->
        <reg32 offset="0x0102C" name="CONTROL2">
            <bitfield pos="7" name="SATURATE_RT4"/>
            <bitfield pos="15" name="SATURATE_RT5"/>
            <bitfield pos="23" name="SATURATE_RT6"/>
            <bitfield pos="31" name="SATURATE_RT7"/>
        </reg32>
        <reg32 offset="0x01030" name="CONTROL_EXT">
            <bitfield high="2" low="0" name="OUTPUT_MODE0" type="COLOR_OUTPUT_MODE"/>
            <bitfield high="6" low="4" name="OUTPUT_MODE1" type="COLOR_OUTPUT_MODE"/>
            <bitfield high="10" low="8" name="OUTPUT_MODE2" type="COLOR_OUTPUT_MODE"/>
            <bitfield high="14" low="12" name="OUTPUT_MODE3" type="COLOR_OUTPUT_MODE"/>
            <bitfield high="18" low="16" name="OUTPUT_MODE4" type="COLOR_OUTPUT_MODE"/>
            <bitfield high="22" low="20" name="OUTPUT_MODE5" type="COLOR_OUTPUT_MODE"/>
            <bitfield high="26" low="24" name="OUTPUT_MODE6" type="COLOR_OUTPUT_MODE"/>
            <bitfield high="30" low="28" name="OUTPUT_MODE7" type="COLOR_OUTPUT_MODE"/>
        </reg32>
        <reg32 offset="0x01034" name="UNK01034"/> <!-- always 0x3f? -->
        <reg32 offset="0x01038" name="UNK01038"/> <!-- numRT == 8 -->
        <!-- Following value pattern looks like a swizzle -->
        <reg32 offset="0x0103C" name="HALTI3_UNK0103C" value="0x76543210"/> <!-- HALTI3 kernel driver puts this under "pixel engine states" -->
        <reg32 offset="0x01040" name="UNK01040" length="2" stride="4"/> <!-- HALTI2 -->
        <reg32 offset="0x01048" name="ICACHE_PREFETCH" brief="Trigger icache prefetch"/>
        <reg32 offset="0x0104C" name="ICACHE_UNK0104C" type="VIVM"/> <!-- !HALTI5 && ICACHE_PREFETCH -->
        <reg32 offset="0x01054" name="MSAA_CONFIG"> <!-- HALTI4 -->
            <!-- Multisampling related masked state.
                 6fffffff SAMPLE_COVERAGE
                 f70fffff SAMPLE_COVERAGE_VALUE
                 fff6ffff ?
                 ffff6fff ALPHA_TO_COVERAGE
                 fffff6ff SAMPLE_MASK
                 ffffff7f ?
             -->
        </reg32>
        <reg32 offset="0x01058" name="SAMPLER_BASE" brief="Offset value applied to sampler index from PS"/> <!-- HALTI5 -->
        <!-- Looks like the blob writes the same values here as to 00A90+x, at least in
             many cases. Might be varying num components (which used to be in GL).
         -->
        <reg32 offset="0x01080" name="VARYING_NUM_COMPONENTS" type="VARYING_NUM_COMPONENTS" length="4" stride="4"/> <!-- HALTI5 -->
        <reg32 offset="0x0087C" name="NEWRANGE_LOW"/> <!-- HALTI5 || ICACHE -->
        <reg32 offset="0x01090" name="NEWRANGE_HIGH"/> <!-- HALTI5 -->
        <reg32 offset="0x01094" name="ICACHE_COUNT" brief="Number of instructions minus one"/> <!-- HALTI5 && ICACHE_PREFETCH -->
        <reg32 offset="0x01098" name="HALTI5_UNK01098"/> <!-- HALTI5 -->
        <reg32 offset="0x0109C" name="PSCS_THROTTLE"/> <!-- PSCS_THROTTLE -->
        <reg32 offset="0x010A0" name="NN_INST_ADDR" type="VIVM" brief="Memory address of NN kernel instructions, must be aligned to 0x100"/> <!-- ICACHE -->
        <reg32 offset="0x010B8" name="TP_INST_ADDR" type="VIVM" brief="Memory address of TP kernel instructions, must be aligned to 0x100"/> <!-- ICACHE -->
        <reg32 offset="0x06000" name="INST_MEM" value="0x00000000" length="1024" stride="4"> <!-- instructionCount <= 256 -->
            <!-- length="instructionCount * 4" -->
        </reg32>
        <reg32 offset="0x07000" name="UNIFORMS" value="0x00000000" length="1024" stride="4">
            <!-- length="fragmentUniforms * 4" -->
        </reg32>
    </stripe>

    <stripe name="GS" brief="Geometry Shader states"> <!-- GEOMETRY_SHADER -->
        <doc>The Geometry shader to use is configured here</doc>
        <reg32 offset="0x01100" name="UNK01100"/>
        <reg32 offset="0x01104" name="UNK01104" value="0x00000001"/>
        <reg32 offset="0x01108" name="UNK01108" value="0x01000001"/>
        <reg32 offset="0x0110C" name="UNK0110C"/>
        <reg32 offset="0x01110" name="UNK01110"/>
        <reg32 offset="0x01114" name="UNK01114" type="VIVM"/>
        <reg32 offset="0x01118" name="ICACHE_PREFETCH" brief="Trigger icache prefetch"/>
        <reg32 offset="0x0111C" name="UNK0111C"/>
        <reg32 offset="0x01120" name="UNK01120" length="8" stride="4"/>
        <reg32 offset="0x01140" name="UNK01140"/>
        <reg32 offset="0x01144" name="UNK01144"/>
        <reg32 offset="0x01148" name="UNK01148"/>
        <reg32 offset="0x0114C" name="UNK0114C"/>
        <reg32 offset="0x01154" name="UNK01154"/>
    </stripe>

    <stripe name="TCS" brief="Tesselation C Shader states"> <!-- TESSELATION_SHADER -->
        <doc>?</doc>
        <reg32 offset="0x007C0" name="UNK007C0" value="0x00000003"/>

        <reg32 offset="0x14A00" name="UNK14A00"/>
        <reg32 offset="0x14A04" name="UNK14A04"/>
        <reg32 offset="0x14A08" name="UNK14A08" type="VIVM"/>
        <reg32 offset="0x14A0C" name="ICACHE_PREFETCH" brief="Trigger icache prefetch"/>
        <reg32 offset="0x14A10" name="UNK14A10"/>
        <reg32 offset="0x14A14" name="UNK14A14"/>
        <reg32 offset="0x14A18" name="UNK14A18"/>
        <reg32 offset="0x14A1C" name="UNK14A1C"/>
        <reg32 offset="0x14A20" name="UNK14A20" length="8" stride="4"/>
        <reg32 offset="0x14A40" name="UNK14A40"/>
        <reg32 offset="0x14A44" name="UNK14A44"/>
        <reg32 offset="0x14A4C" name="UNK14A4C"/>
    </stripe>

    <stripe name="TES" brief="Tesselation E Shader states"> <!-- TESSELATION_SHADER -->
        <doc>?</doc>
        <reg32 offset="0x14B00" name="UNK14B00"/>
        <reg32 offset="0x14B04" name="UNK14B04"/>
        <reg32 offset="0x14B08" name="UNK14B08"/>
        <reg32 offset="0x14B0C" name="UNK14B0C" type="VIVM"/>
        <reg32 offset="0x14B10" name="ICACHE_PREFETCH" brief="Trigger icache prefetch"/>
        <reg32 offset="0x14B14" name="UNK14B14"/>
        <reg32 offset="0x14B18" name="UNK14B18"/>
        <reg32 offset="0x14B1C" name="UNK14B1C"/>
        <reg32 offset="0x14B20" name="UNK14B20"/>
        <reg32 offset="0x14B24" name="UNK14B24"/>
        <reg32 offset="0x14B2C" name="UNK14B2C"/>
        <reg32 offset="0x14B34" name="UNK14B34"/>
        <reg32 offset="0x14B40" name="UNK14B40" length="8" stride="4"/>
    </stripe>

    <stripe name="TFB" brief="HW TFB states"> <!-- HW_TFB -->
        <doc>TFB = transform feedback?</doc>
        <reg32 offset="0x1C000" name="UNK1C000"/>
        <reg32 offset="0x1C008" name="UNK1C008" type="VIVM"/>
        <reg32 offset="0x1C00C" name="FLUSH"/> <!-- Flush writes 0x12345678 here in kernel driver -->
        <reg32 offset="0x1C014" name="UNK1C014" type="VIVM"/>
        <reg32 offset="0x1C040" name="UNK1C040" type="VIVM" length="4" stride="4"/>
        <reg32 offset="0x1C080" name="UNK1C080" length="4" stride="4"/>
        <reg32 offset="0x1C0C0" name="UNK1C0C0" length="4" stride="4"/>
        <reg32 offset="0x1C100" name="UNK1C100" length="4" stride="4"/>
        <reg32 offset="0x1C800" name="UNK1C800" length="512" stride="4"/> <!-- 128*4 -->
    </stripe>

    <stripe name="PE" brief="Pixel Engine states">
        <doc>The Pixel Engine takes care of writing pixels to the framebuffer, doing
            blending, depth testing and alpha testing if needed.

            Some flags can be set either per group of bits, or all at once, by using masking flags.
            Each group of state flags has a masking flag that when set prevents overwriting the flags in that group.
            These will be called FOO_MASK if the state to be masked is called FOO.
        </doc>
        <reg32 offset="0x01400" name="DEPTH_CONFIG" value="0x00000000">
            <bitfield high="1" low="0" name="DEPTH_MODE">
                <value value="0" name="NONE"/>
                <value value="1" name="Z" brief="Z-buffer"/>
                <value value="2" name="W" brief="W-buffer"/>
            </bitfield>
            <bitfield pos="3" name="DEPTH_MODE_MASK"/>
            <bitfield pos="4" name="DEPTH_FORMAT">
                <value value="0" name="D16"/>
                <value value="1" name="D24S8"/>
            </bitfield>
            <bitfield pos="5" name="DEPTH_FORMAT_MASK"/>
            <bitfield high="10" low="8" name="DEPTH_FUNC" type="COMPARE_FUNC" brief="glDepthFunc"/>
            <bitfield pos="11" name="DEPTH_FUNC_MASK"/>
            <bitfield pos="12" name="WRITE_ENABLE" brief="glDepthMask"/>
            <bitfield pos="13" name="WRITE_ENABLE_MASK"/>
            <bitfield pos="16" name="EARLY_Z"/>
            <bitfield pos="17" name="EARLY_Z_MASK"/>
            <bitfield pos="18" name="UNK18"/> <!-- Probably depth compression, blob always enables this -->
            <bitfield pos="19" name="UNK18_MASK"/>
            <bitfield pos="20" name="ONLY_DEPTH"/>
            <bitfield pos="21" name="ONLY_DEPTH_MASK"/>
            <bitfield pos="24" name="DISABLE_ZS">
                <doc>
                    Disables the late ZS stage (both testing and writes). On GPUs that can write
                    depth from the early (RA) stage, the late stage must be disabled when early
                    writes are active, otherwise the GPU hangs.
                </doc>
            </bitfield>
            <bitfield pos="25" name="DISABLE_ZS_MASK"/>
            <bitfield pos="26" name="SUPER_TILED"/>
            <bitfield pos="27" name="SUPER_TILED_MASK"/>
        </reg32>
        <reg32 offset="0x01404" name="DEPTH_NEAR" value="0x00000000" type="float"/>
        <reg32 offset="0x01408" name="DEPTH_FAR" value="0x00000000" type="float"/>
        <reg32 offset="0x0140C" name="DEPTH_NORMALIZE" value="0x00000000" type="float"/>
        <reg32 offset="0x01410" name="DEPTH_ADDR" value="0x00000000" type="VIVM"/> <!-- pixelPipes == 1 -->
        <reg32 offset="0x01414" name="DEPTH_STRIDE" value="0x00000000"/>
        <reg32 offset="0x01418" name="STENCIL_OP" value="0x00000000" masked="yes">
            <bitfield high="2" low="0" name="FUNC_FRONT" type="COMPARE_FUNC" brief="glStencilFunc func (GL_FRONT)"/>
            <bitfield pos="3" name="FUNC_FRONT_MASK"/>
            <bitfield high="6" low="4" name="PASS_FRONT" type="STENCIL_OP" brief="glStencilOp dppass (GL_FRONT)"/>
            <bitfield pos="7" name="PASS_FRONT_MASK"/>
            <bitfield high="10" low="8" name="FAIL_FRONT" type="STENCIL_OP" brief="glStencilOp sfail (GL_FRONT)"/>
            <bitfield pos="11" name="FAIL_FRONT_MASK"/>
            <bitfield high="14" low="12" name="DEPTH_FAIL_FRONT" type="STENCIL_OP" brief="glStencilOp dpfail (GL_FRONT)"/>
            <bitfield pos="15" name="DEPTH_FAIL_FRONT_MASK"/>
            <bitfield high="18" low="16" name="FUNC_BACK" type="COMPARE_FUNC" brief="glStencilFunc func (GL_BACK)"/>
            <bitfield pos="19" name="FUNC_BACK_MASK"/>
            <bitfield high="22" low="20" name="PASS_BACK" type="STENCIL_OP" brief="glStencilOp dppass (GL_BACK)"/>
            <bitfield pos="23" name="PASS_BACK_MASK"/>
            <bitfield high="26" low="24" name="FAIL_BACK" type="STENCIL_OP" brief="glStencilOp sfail (GL_BACK)"/>
            <bitfield pos="27" name="FAIL_BACK_MASK"/>
            <bitfield high="30" low="28" name="DEPTH_FAIL_BACK" type="STENCIL_OP" brief="glStencilOp dpfail (GL_BACK)"/>
            <bitfield pos="31" name="DEPTH_FAIL_BACK_MASK"/>
        </reg32>
        <reg32 offset="0x0141C" name="STENCIL_CONFIG" value="0x00000000" masked="yes">
            <doc>Warning: confusing terminology. WRITE_MASK is the stencil write mask,
                the state bits can be masked with WRITE_MASK_MASK.</doc>
            <bitfield high="1" low="0" name="MODE">
                <value value="0" name="DISABLED" brief="Stencil disabled"/>
                <value value="1" name="ONE_SIDED" brief="Stencil enabled in one-sided mode"/>
                <value value="2" name="TWO_SIDED" brief="Stencil enabled in two-sided mode"/>
            </bitfield>
            <bitfield pos="4" name="MODE_MASK"/>
            <bitfield pos="5" name="REF_FRONT_MASK"/>
            <bitfield pos="6" name="MASK_FRONT_MASK"/>
            <bitfield pos="7" name="WRITE_MASK_MASK"/>
            <bitfield high="15" low="8" name="REF_FRONT" brief="glStencilFunc ref (GL_FRONT)">
                <doc>REF_BACK is in register STENCIL_CONFIG_EXT.</doc>
            </bitfield>
            <bitfield high="23" low="16" name="MASK_FRONT" brief="glStencilFunc mask (GL_FRONT)">
                <doc>MASK_BACK is in register STENCIL_CONFIG_EXT2.</doc>
            </bitfield>
            <bitfield high="31" low="24" name="WRITE_MASK_FRONT" brief="glStencilMask (GL_FRONT)">
                <doc>WRITE_MASK_BACK is in register STENCIL_CONFIG_EXT2.</doc>
            </bitfield>
        </reg32>
        <reg32 offset="0x01420" name="ALPHA_OP" value="0x00000000" masked="yes">
            <bitfield pos="0" name="ALPHA_TEST"/>
            <bitfield pos="1" name="ALPHA_TEST_MASK"/>
            <bitfield high="6" low="4" name="ALPHA_FUNC" type="COMPARE_FUNC"/>
            <bitfield pos="7" name="ALPHA_FUNC_MASK"/>
            <bitfield high="15" low="8" name="ALPHA_REF"/>
            <bitfield pos="16" name="ALPHA_REF_MASKFUNC_MASK"/>
        </reg32>
        <reg32 offset="0x01424" name="ALPHA_BLEND_COLOR" value="0x00000000">
            <bitfield high="7" low="0" name="B"/>
            <bitfield high="15" low="8" name="G"/>
            <bitfield high="23" low="16" name="R"/>
            <bitfield high="31" low="24" name="A"/>
        </reg32>
        <reg32 offset="0x01428" name="ALPHA_CONFIG" value="0x00000000" masked="yes">
            <bitfield pos="0" name="BLEND_ENABLE_COLOR" brief="Enable alpha blending"/>
            <bitfield pos="1" name="BLEND_ENABLE_COLOR_MASK"/>
            <bitfield pos="2" name="SRC_FUNC_COLOR_MASK"/>
            <bitfield pos="3" name="DST_FUNC_COLOR_MASK"/>
            <bitfield high="7" low="4" name="SRC_FUNC_COLOR" type="BLEND_FUNC"/>
            <bitfield high="11" low="8" name="DST_FUNC_COLOR" type="BLEND_FUNC"/>
            <bitfield high="14" low="12" name="EQ_COLOR" type="BLEND_EQ"/>
            <bitfield pos="15" name="EQ_COLOR_MASK"/>
            <bitfield pos="16" name="BLEND_SEPARATE_ALPHA" brief="Enable separate blending for alpha"/>
            <bitfield pos="17" name="BLEND_SEPARATE_ALPHA_MASK"/>
            <bitfield pos="18" name="SRC_FUNC_ALPHA_MASK"/>
            <bitfield pos="19" name="DST_FUNC_ALPHA_MASK"/>
            <bitfield high="23" low="20" name="SRC_FUNC_ALPHA" type="BLEND_FUNC"/>
            <bitfield high="27" low="24" name="DST_FUNC_ALPHA" type="BLEND_FUNC"/>
            <bitfield high="30" low="28" name="EQ_ALPHA" type="BLEND_EQ"/>
            <bitfield pos="31" name="EQ_ALPHA_MASK"/>
        </reg32>
        <reg32 offset="0x0142C" name="COLOR_FORMAT" value="0x00000000">
            <bitfield high="3" low="0" name="FORMAT" type="PE_FORMAT"/>
            <bitfield pos="4" name="FORMAT_MASK"/>
            <bitfield high="11" low="8" name="COMPONENTS" type="RGBA_BITS" brief="glColorMask"/>
            <bitfield pos="12" name="COMPONENTS_MASK"/>
            <bitfield pos="13" name="SUPER_TILED_NEW"/> <!-- CACHE128B256BPERLINE -->
            <bitfield pos="16" name="OVERWRITE" brief="Set to 1 when destination fully overwritten, so no alpha blending and masked components"/>
            <bitfield pos="17" name="OVERWRITE_MASK"/>
            <bitfield pos="20" name="SUPER_TILED"/>
            <bitfield pos="21" name="SUPER_TILED_MASK"/>
            <!-- Vivante driver on GC2000/GC3000/GC7000 specifies output format here and sets
                 FORMAT to 0 and FORMAT_MASK to 1.
              -->
            <bitfield high="30" low="24" name="FORMAT_EXT" type="PE_FORMAT"/>
            <bitfield pos="31" name="FORMAT_EXT_MASK"/>
        </reg32>
        <reg32 offset="0x01430" name="COLOR_ADDR" value="0x00000000" type="VIVM"/> <!-- pixelPipes == 1 -->
        <reg32 offset="0x01434" name="COLOR_STRIDE" value="0x00000000"/>
        <reg32 offset="0x01454" name="HDEPTH_CONTROL" value="0x00000000">
            <bitfield high="3" low="0" name="FORMAT">
                <value value="0" name="DISABLED" brief="Hierarchical Z disabled"/>
                <value value="5" name="D16" brief="16 bit depth"/>
                <value value="8" name="D24S8" brief="24 bit depth (+8 bit stencil or padding)"/>
            </bitfield>
        </reg32>
        <reg32 offset="0x01458" name="HDEPTH_ADDR" value="0x00000000" type="VIVM"/>
        <reg32 offset="0x0145C" name="UNK0145C" value="0x00000010"/>
        <stripe name="PIPE" length="8" stride="4"> <!-- pixelPipes != 1 -->
            <!-- length="pixelPipes" -->
            <reg32 offset="0x1460" name="COLOR_ADDR" value="0x00000000" type="VIVM"/>
            <reg32 offset="0x1480" name="DEPTH_ADDR" value="0x00000000" type="VIVM"/>
            <reg32 offset="0x1500" name="ADDR_UNK01500" value="0x00000000" type="VIVM"/>
            <reg32 offset="0x1520" name="ADDR_UNK01520" value="0x00000000" type="VIVM"/>
            <reg32 offset="0x1540" name="ADDR_UNK01540" value="0x00000000" type="VIVM"/>
        </stripe>
        <reg32 offset="0x014A0" name="STENCIL_CONFIG_EXT" value="0x00000000" masked="yes">
            <bitfield high="7" low="0" name="REF_BACK" brief="glStencilFunc ref (GL_BACK)"/>
            <bitfield pos="8" name="REF_BACK_MASK"/>
            <bitfield pos="9" name="UNK16_MASK"/>
            <bitfield high="31" low="16" name="EXTRA_ALPHA_REF"/>
        </reg32>
        <reg32 offset="0x014A4" name="LOGIC_OP" masked="yes" value="0x000E400C">
            <!-- only supported if feature bit LOGIC_OP present.
                 Either a coincidence or due to shared roots in DirectX: same enum as Gallium3D PIPE_LOGICOP -->
            <bitfield high="3" low="0" name="OP" type="LOGIC_OP"/>
            <bitfield pos="4" name="OP_MASK"/>
            <!-- Global PE state not related to logic operations but "conveniently"
                 squashed into this register.
            -->
            <!-- not sure what DITHER_MODE does, but blob always sets it to 2 or 3, and it is related to dithering
                 if its 0 on GC2000/GC3000, alpha blending with gl_FragColor = (1.0, 1.0, 1.0, 0.0) and dithering on,
                 whitens instead of having no effect. maybe one bit is for color and one for alpha?
            -->
            <bitfield high="6" low="5" name="DITHER_MODE"/>
            <bitfield pos="7" name="SINGLE_BUFFER_MASK"/>
            <!-- SINGLE_BUFFER is a feature, introduced in GC3000 on i.MX6qp, that allows
                 multiple pixel pipes to render to a single buffer. This is very useful:

                 - The PRE unit on i.MX6qp can handle Vivante's tiled formats but not
                   multi-tiled formats.
                 - Could make render-to-texture less of a hassle.

                 It is apparently switched on by setting the following state to
                 2 or 3, and assigning the same address to both pixel pipes for both
                 depth and color.
            -->
            <bitfield high="9" low="8" name="SINGLE_BUFFER"/>
            <bitfield pos="10" name="DITHER_MODE_MASK"/>
            <bitfield pos="11" name="UNK11"/> <!-- Alpha related -->
            <bitfield high="21" low="20" name="UNK20"/> <!-- Depth related -->
            <bitfield pos="23" name="UNK20_MASK"/>
            <bitfield high="26" low="24" name="UNK24"/> <!-- SMALL_MSAA -->
            <bitfield pos="27" name="UNK24_MASK"/>
            <bitfield pos="30" name="SRGB_MASK"/>
            <bitfield pos="31" name="SRGB"/> <!-- linear to sRGB convert output -->
        </reg32>
        <reg32 offset="0x014A8" name="DITHER" value="0xFFFFFFFF" length="2"/>
        <reg32 offset="0x014B0" name="ALPHA_COLOR_EXT0" value="0x00000000" brief="High-precision alpha blend color"> <!--HALF_FLOAT_PIPE-->
            <bitfield high="15" low="0" name="B" type="float"/> <!-- 16-bit float -->
            <bitfield high="31" low="16" name="G" type="float"/> <!-- 16-bit float -->
        </reg32>
        <reg32 offset="0x014B4" name="ALPHA_COLOR_EXT1" value="0x00000000" brief="High-precision alpha blend color"> <!--HALF_FLOAT_PIPE-->
            <bitfield high="15" low="0" name="R" type="float"/> <!-- 16-bit float -->
            <bitfield high="31" low="16" name="A" type="float"/> <!-- 16-bit float -->
        </reg32>
        <reg32 offset="0x014B8" name="STENCIL_CONFIG_EXT2" value="0x00000000">
            <bitfield high="7" low="0" name="MASK_BACK" brief="glStencilFunc mask (GL_BACK)"/>
            <bitfield high="15" low="8" name="WRITE_MASK_BACK" brief="glStencilMask (GL_BACK)"/>
        </reg32>
        <reg32 offset="0x014BC" name="MEM_CONFIG"> <!-- HALTI3 -->
            <bitfield pos="24" name="COLOR_TS_MODE" type="TS_MODE"/>
            <bitfield pos="26" name="DEPTH_TS_MODE" type="TS_MODE"/>
        </reg32>
        <reg32 offset="0x014C0" name="HALTI4_UNK014C0"/> <!-- HALTI4 -->
        <reg32 offset="0x014C4" name="ROBUSTNESS_UNK014C4"/> <!-- ROBUSTNESS -->
        <reg32 offset="0x01580" name="UNK01580" value="0x00000000" length="3" stride="4"/>
        <!-- Multiple render targets (color attachments).
             These figure output 1..N as index 0..N-1.
         -->
        <stripe name="RT_ADDR" length="8" stride="0x20">
            <reg32 offset="0x14800" name="PIPE" length="8" stride="4" type="VIVS"/>
        </stripe>
        <reg32 offset="0x14900" name="RT_CONFIG" length="8" stride="4">
            <bitfield high="15" low="0" name="STRIDE"/>
            <!-- Likely per-output format flags -->
            <bitfield high="20" low="16" name="FORMAT" type="PE_FORMAT"/>
            <bitfield pos="26" name="SUPER_TILED"/>
            <bitfield pos="28" name="UNK28"/>
        </reg32>

        <!-- HALTI5 extra per-RT state -->
        <reg32 offset="0x14920" name="HALTI5_UNK14920" length="7" stride="4">
            <bitfield high="7" low="4" name="COMPONENTS" type="RGBA_BITS"/>
            <bitfield pos="8" name="UNK8"/>
        </reg32>
        <reg32 offset="0x14940" name="HALTI5_UNK14940" length="7" stride="4"/>
        <reg32 offset="0x14960" name="HALTI5_UNK14960" length="7" stride="4"/>
        <reg32 offset="0x14980" name="HALTI5_UNK14980" length="7" stride="4"/>
        <reg32 offset="0x149A0" name="HALTI5_UNK149A0" length="7" stride="4"/>

        <reg32 offset="0x149C0" name="ROBUSTNESS_UNK149C0" length="8" stride="4"/> <!-- ROBUSTNESS -->
    </stripe>

    <stripe name="CO" brief="Compose states">
        <doc>Hardware composer. This functionality is present on some GCxxxx chips and allows
            for blending surfaces together with Porter-Diff composition methods, to accelerate the
            likes of Surfaceflinger (Android).</doc>
        <reg32 offset="0x03008" name="UNK03008" value="0x00000000"/>
        <reg32 offset="0x0300C" name="KICKER"/>
        <reg32 offset="0x03010" name="UNK03010"/>
        <reg32 offset="0x03014" name="UNK03014"/>
        <reg32 offset="0x03018" name="UNK03018"/>
        <reg32 offset="0x0301C" name="UNK0301C"/>
        <reg32 offset="0x03020" name="UNK03020"/>
        <reg32 offset="0x03024" name="UNK03024"/>
        <reg32 offset="0x03040" name="UNK03040"/>
        <reg32 offset="0x03044" name="UNK03044"/>
        <reg32 offset="0x03048" name="UNK03048"/>
        <reg32 offset="0x0304C" name="ICACHE_UNK0304C"/> <!-- ICACHE -->
        <stripe name="SAMPLER" length="8" stride="4">
            <reg32 offset="0x03060" name="UNK03060"/>
            <reg32 offset="0x03080" name="UNK03080"/>
            <reg32 offset="0x030A0" name="UNK030A0"/>
            <reg32 offset="0x030C0" name="UNK030C0"/>
            <reg32 offset="0x030E0" name="UNK030E0"/>
            <reg32 offset="0x03100" name="UNK03100"/>
            <reg32 offset="0x03120" name="UNK03120"/>
            <reg32 offset="0x03140" name="UNK03140"/>
            <reg32 offset="0x03160" name="UNK03160"/>
            <reg32 offset="0x03180" name="UNK03180"/>
            <reg32 offset="0x031A0" name="UNK031A0"/>
            <reg32 offset="0x031C0" name="UNK031C0"/>
            <reg32 offset="0x031E0" name="UNK031E0"/>
        </stripe>
        <array offset="0x03200" name="ADDR_UNK03200" length="8" stride="0x20">
            <reg32 offset="0" name="PPIPE" length="8"/> <!-- sampler*0x20 + pixelpipe*0x4 -->
        </array>
    </stripe>

    <stripe name="RS" brief="Resolve states">
        <doc>To my current understanding, RESOLVE is a multifunctional copy/fill engine that can copy blocks of pixels from
            one place in memory to another, actually clearing tiles that are marked as cleared in the process.
            Other capabilities are:

            - Conversion between pixel formats
            - Downsampling (2x horizontal or horizontal and vertical)
            - Fill with constant value
            - Partial fill (only clear part of the channels)
            - Tiling / untiling, for normal tiled and supertiled surfaces
            - Swap blue and red channels, flip image in Y
            - Endian swapping
            - Fill tiles that are marked as 'cleared' in the Tile Status

            The following render target tilings are possible:

                A   B   C
                0   x   x   Linear
                1   0   0   Tiled (4x4, like textures)
                1   1   0   Supertiled (64x64)
                1   0   1   Multi-tiled (4x4, like textures)
                1   1   1   Multi-supertiled (64x64)

             A) tiled: SOURCE_TILED, DEST_TILED in CONFIG word
             B) supertiled: TILING bit in SOURCE_STRIDE / DEST_STRIDE
             C) multi: MULTI bit in SOURCE_STRIDE / DEST_STRIDE

             GC2000 and other GPUs with multiple pixel pipes have additional multi-pipe tiling formats,
             which are used by the PE when rendering as an extra form of paralelism.
             When multitiling the image is divided up vertically into separate units with their own
             starting address.
        </doc>
        <reg32 offset="0x01600" name="KICKER" brief="Resolve start" value="0x00000000">
            <doc>Write some value to this register to kick off resolver</doc>
        </reg32>
        <reg32 offset="0x01604" name="CONFIG" brief="Resolve configuration register" value="0x00000000">
            <bitfield high="4" low="0" name="SOURCE_FORMAT" type="RS_FORMAT" brief="Source color format">
                <doc>
                    For clear operations, this specifies the format that CLEAR_CONTROL.BITS is in.
                </doc>
            </bitfield>
            <bitfield pos="5" name="DOWNSAMPLE_X" brief="Downsampling horizontally"/>
            <bitfield pos="6" name="DOWNSAMPLE_Y" brief="Downsampling vertically"/>
            <bitfield pos="7" name="SOURCE_TILED" brief="Source is tiled"/>
            <bitfield high="12" low="8" name="DEST_FORMAT" type="RS_FORMAT" brief="Destination color format"/>
            <bitfield pos="14" name="DEST_TILED" brief="Destination is tiled"/>
            <bitfield pos="29" name="SWAP_RB" brief="Swap red and blue"/>
            <bitfield pos="30" name="FLIP" brief="Flip image in Y direction"/>
        </reg32>
        <reg32 offset="0x01608" name="SOURCE_ADDR" value="0x00000000" type="VIVM"/>
        <reg32 offset="0x0160C" name="SOURCE_STRIDE" value="0x00000000">
            <bitfield high="17" low="0" name="STRIDE" brief="Source stride"/>
            <bitfield pos="29" name="TS_MODE" type="TS_MODE"/> <!-- CACHE128B256BPERLINE || SMALL_MSAA -->
            <bitfield pos="27" name="SUPER_TILED_NEW" brief="Source is super tiled"/> <!-- CACHE128B256BPERLINE -->
            <bitfield pos="30" name="MULTI" brief="Source is multi pipe"/> <!-- pixelPipes > 1 -->
            <bitfield pos="31" name="TILING" brief="Source is tiled"/>
        </reg32>
        <reg32 offset="0x01610" name="DEST_ADDR" value="0x00000000" type="VIVM"/>
        <reg32 offset="0x01614" name="DEST_STRIDE" value="0x00000000">
            <bitfield high="17" low="0" name="STRIDE" brief="Destination stride"/>
            <bitfield pos="27" name="SUPER_TILED_NEW" brief="Destination is super tiled"/> <!-- CACHE128B256BPERLINE -->
            <bitfield pos="30" name="MULTI" brief="Destination is multi pipe"/> <!-- pixelPipes > 1 -->
            <bitfield pos="31" name="TILING" brief="Destination is tiled"/>
        </reg32>
        <reg32 offset="0x01620" name="WINDOW_SIZE" value="0x00000000" brief="Size of area to resolve">
            <doc>
                When downsampling the source and destination size will be different.
                In this case, the WINDOW_SIZE will be the (unscaled) source size.
            </doc>
            <bitfield high="31" low="16" name="HEIGHT" type="uint"/>
            <bitfield high="15" low="0" name="WIDTH" type="uint"/>
        </reg32>
        <reg32 offset="0x01630" name="DITHER" value="0x00000000" length="2" stride="4"/>
        <reg32 offset="0x0163C" name="CLEAR_CONTROL" value="0x00000000">
            <bitfield high="15" low="0" name="BITS" brief="Affects which channels of which tiles are cleared">
                <doc>
                    Four groups (per tile) of four bits (per channel) that affect which channels of which tiles are cleared.
                    In mode 'enabled' only the lower four bits are used, in 'enabled2' all four groups are used.

                    Components that are disabled are not written at all by the clear logic (they keep their old value)
                    they are not copied from the source.
                </doc>
            </bitfield>
            <bitfield high="17" low="16" name="MODE" brief="Enable clearing">
                <doc>
                    Depending on the clear mode, the RS does different things:
                    - If disabled, it is a copy engine
                    - If enabled, it fills the target area with FILL_VALUE(0) and disregards the source
                    - If enabled2, it fills the target area with the four FILL_VALUEs (results in vertical stripes of width 4,
                       at least with supertiled target) and disregards the source.
                </doc>
                <value value="0" name="DISABLED"/>
                <value value="1" name="ENABLED1" brief="Clear single value"/>
                <value value="2" name="ENABLED4" brief="Clear with four alternating tile values"/>
                <value value="3" name="ENABLED4_2" brief="Clear with alternating tile values (2)"/>
            </bitfield>
        </reg32>
        <reg32 offset="0x01640" name="FILL_VALUE" value="0x00000000" length="4" stride="4"/>
        <reg32 offset="0x016A0" name="EXTRA_CONFIG" value="0x00000000">
            <bitfield high="1" low="0" name="AA" brief="Anti-aliasing mode (not used for MSAA)"/>
            <bitfield high="9" low="8" name="ENDIAN" type="ENDIAN_MODE"/>
            <bitfield pos="20" name="UNK20"/>
            <bitfield pos="24" name="TS_MODE" type="TS_MODE"/>
            <bitfield pos="28" name="UNK28"/>
        </reg32>
        <reg32 offset="0x016B0" name="KICKER_INPLACE" value="0x00000000" brief="Triggers an in-place resolve, where the value is the number of tiles">
            <doc>
                GC3000 and up: triggers an in-place resolve.

                Seems the value written is the number of tiles to process.
                After writing this value, all tiles that are not yet filled
                according to TS will be filled in, without a copy operation.

                The blob queues the following state changes afterwards:
                    GL.FLUSH_CACHE := COLOR
                    DUMMY.DUMMY := 0x0
            </doc>
        </reg32>
        <reg32 offset="0x016B4" name="UNK016B4" value="0x00000000"/>
        <reg32 offset="0x016B8" name="SINGLE_BUFFER">
            <bitfield pos="0" name="ENABLE"/> <!-- Has to do with SINGLE_BUFFER feature - enabling this only resolves first pipe address -->
        </reg32>
        <stripe name="PIPE" length="8" stride="4"> <!-- pixelPipes > 1 -->
            <!-- length="pixelPipes" -->
            <reg32 offset="0x016C0" name="SOURCE_ADDR" value="0x00000000" type="VIVM"/>
            <reg32 offset="0x016E0" name="DEST_ADDR" value="0x00000000" type="VIVM"/>
            <reg32 offset="0x01700" name="OFFSET" value="0x00000000">
                <bitfield high="15" low="0" name="X" type="int"/> <!-- guess -->
                <bitfield high="31" low="16" name="Y" type="int"/> <!-- guess -->
            </reg32>
        </stripe>
    </stripe>

    <stripe name="TS" brief="Tile Status">
        <doc>
        Tile status block contains information about the tiles to be resolved.
        It is used by the PE (to read/update tile status) as well as the RS (to read tile status for source).
        </doc>
        <reg32 offset="0x01650" name="FLUSH_CACHE" brief="Flush resolve cache" value="0x00000000"> <!-- FC_FLUSH_STALL -->
            <bitfield pos="0" name="FLUSH" brief="Flush tile status cache"/>
        </reg32>
        <reg32 offset="0x01654" name="MEM_CONFIG" brief="Memory configuration" value="0x00200000">
            <doc>
                Tile status config. Setting this value to 0 disables tile status and makes the resolve
                work like a normal copy engine.
            </doc>
            <bitfield pos="0" name="DEPTH_FAST_CLEAR" brief="Clear depth tiles on resolve"/>
            <bitfield pos="1" name="COLOR_FAST_CLEAR" brief="Clear color tiles on resolve"/>
            <bitfield pos="3" name="DEPTH_16BPP"/>
            <bitfield pos="4" name="DEPTH_AUTO_DISABLE" brief="Auto disable fast clear for depth"/>
            <bitfield pos="5" name="COLOR_AUTO_DISABLE" brief="Auto disable fast clear for color"/>
            <bitfield pos="6" name="DEPTH_COMPRESSION" brief="Enable depth compression"/>
            <bitfield pos="7" name="COLOR_COMPRESSION" brief="Enable color compression">
                <doc>
                    The type of color compression used depends on the GPU. On older GPUs the color compression
                    was a lossy format, specifically used when MSAA was enabled.

                    On GC7000 this field and COLOR_COMPRESSION_FORMAT seem to be set based on DEC400 enable/disable;
                    if VIV_DISABLE_DEC400, this is set to 0 and COLOR_COMPRESSION_FORMAT also 0.
                    If DEC400 enabled, this is (sometimes) set to 1 and COLOR_COMPRESSION_FORMAT is 3.
                </doc>
            </bitfield>
            <bitfield high="11" low="8" name="COLOR_COMPRESSION_FORMAT" type="COMPRESSION_FORMAT"/>
            <bitfield pos="12" name="UNK12"/> <!-- likely has to do with hdepth HDEPTH_FAST_CLEAR? -->
            <bitfield pos="13" name="HDEPTH_AUTO_DISABLE" brief="Auto disable fast clear for hdepth"/>
            <bitfield pos="14" name="STENCIL_ENABLE"/> <!-- GC7000L - only required when depth compression is on? -->
            <bitfield pos="21" name="UNK21"/> <!-- Set by default in new context w/ Vivante kernel driver -->
        </reg32>
        <reg32 offset="0x01658" name="COLOR_STATUS_BASE" brief="Color tile status base address" value="0x00000000" type="VIVM"/>
        <reg32 offset="0x0165C" name="COLOR_SURFACE_BASE" brief="Color surface base address" value="0x00000000" type="VIVM"/>
        <reg32 offset="0x01660" name="COLOR_CLEAR_VALUE" brief="Color clear value" value="0x00000000"/>
        <reg32 offset="0x01664" name="DEPTH_STATUS_BASE" brief="Depth tile status base address" value="0x00000000" type="VIVM"/>
        <reg32 offset="0x01668" name="DEPTH_SURFACE_BASE" brief="Depth surface base address" value="0x00000000" type="VIVM"/>
        <reg32 offset="0x0166C" name="DEPTH_CLEAR_VALUE" brief="Depth clear value" value="0x00000000"/>
        <reg32 offset="0x01670" name="DEPTH_AUTO_DISABLE_COUNT" brief="Auto disable depth counter" value="0x00000000"/>
        <reg32 offset="0x01674" name="COLOR_AUTO_DISABLE_COUNT" brief="Auto disable color counter" value="0x00000000"/>
        <reg32 offset="0x016A4" name="HDEPTH_STATUS_BASE" value="0x00000000" type="VIVM">
            <doc>Hierarchical Z allocates multiple depth buffers for one surface, which have their own TS.</doc>
        </reg32>
        <reg32 offset="0x016A8" name="HDEPTH_CLEAR_VALUE" brief="Hierarchical depth clear value" value="0x00000000"/>
        <reg32 offset="0x016AC" name="HDEPTH_SIZE" brief="Size of hierarchical depth buffer divided by 16"/>
        <reg32 offset="0x016BC" name="COLOR_CLEAR_VALUE_EXT" brief="Second color clear value">
            <doc>
                This is used along with TS.COLOR_CLEAR_VALUE to fill in tiles with a
                64-bit pattern instead of a 32-bit pattern.
            </doc>
        </reg32>
        <stripe name="SAMPLER" length="8" stride="4"> <!-- Tile status for samplers -->
            <reg32 offset="0x01720" name="CONFIG" value="0x00000000">
                <bitfield pos="0" name="ENABLE"/>
                <bitfield pos="1" name="COMPRESSION"/>
                <bitfield high="7" low="4" name="COMPRESSION_FORMAT" type="COMPRESSION_FORMAT"/>
                <bitfield high="13" low="11" name="UNK11"/>
            </reg32>
            <reg32 offset="0x01740" name="STATUS_BASE" value="0x00000000" type="VIVM"/>
            <reg32 offset="0x01760" name="CLEAR_VALUE" value="0x00000000"/>
            <!-- New on GC3000 - seems simply a second copy of CLEAR_VALUE -->
            <reg32 offset="0x01780" name="CLEAR_VALUE2" value="0x00000000"/> <!-- HALTI2 -->
            <reg32 offset="0x01A80" name="SURFACE_BASE" type="VIVM"/> <!-- HALTI3 -->
        </stripe>
        <!-- Multiple render targets (color attachments) -->
        <stripe name="RT" length="8" stride="4"> <!-- HALTI2 -->
            <reg32 offset="0x017A0" name="UNK017A0"/>
            <reg32 offset="0x017C0" name="STATUS_BASE" type="VIVM"/>
            <reg32 offset="0x017E0" name="SURFACE_BASE" type="VIVM"/>
            <reg32 offset="0x01A00" name="CLEAR_VALUE"/>
            <reg32 offset="0x01A20" name="CLEAR_VALUE2"/>
            <reg32 offset="0x01A40" name="UNK01A40"/>
        </stripe>
    </stripe>

    <stripe name="YUV" brief="YUV tiler states">
        <doc>The YUV tiler can combine planar YUV formats to RGB or non-planar YUV formats.</doc>
        <reg32 offset="0x01678" name="CONFIG" value="0x00000000">
            <bitfield pos="0" name="ENABLE"/>
            <bitfield high="5" low="4" name="SOURCE_FORMAT" type="uint" brief="Source yuv format"/>
            <bitfield pos="8" name="UV_SWAP"/>
        </reg32>
        <reg32 offset="0x0167C" name="WINDOW_SIZE" value="0x00000000">
            <bitfield high="31" low="16" name="HEIGHT" type="uint"/>
            <bitfield high="15" low="0" name="WIDTH" type="uint"/>
        </reg32>
        <reg32 offset="0x01680" name="Y_BASE" value="0x00000000" type="VIVM"/>
        <reg32 offset="0x01684" name="Y_STRIDE" value="0x00000000"/>
        <reg32 offset="0x01688" name="U_BASE" value="0x00000000" type="VIVM"/>
        <reg32 offset="0x0168C" name="U_STRIDE" value="0x00000000"/>
        <reg32 offset="0x01690" name="V_BASE" value="0x00000000" type="VIVM"/>
        <reg32 offset="0x01694" name="V_STRIDE" value="0x00000000"/>
        <reg32 offset="0x01698" name="DEST_BASE" value="0x00000000" type="VIVM"/>
        <reg32 offset="0x0169C" name="DEST_STRIDE" value="0x00000000"/>
    </stripe>

    <stripe name="TE" brief="TExture sampler states">
        <doc>Texture sampling, filtering, LOD, etc</doc>
        <stripe name="SAMPLER" length="12" stride="4">
            <doc>8 fragment texture samplers, 4 vertex texture samplers</doc>
            <reg32 offset="0x2000" name="CONFIG0" value="0x00000000" type="TE_SAMPLER_CONFIG0"/>
            <reg32 offset="0x2040" name="SIZE" value="0x00000000" type="TE_SAMPLER_SIZE"/>
            <reg32 offset="0x2080" name="LOG_SIZE" value="0x00000000" type="TE_SAMPLER_LOG_SIZE"/>
            <reg32 offset="0x20C0" name="LOD_CONFIG" value="0x00000000" type="TE_SAMPLER_LOD_CONFIG"/>
            <reg32 offset="0x2100" name="UNK02100" value="0x00000000"/>
            <reg32 offset="0x2140" name="UNK02140" value="0x00000000"/>
            <reg32 offset="0x2180" name="3D_CONFIG" value="0x00000000" type="TE_SAMPLER_3D_CONFIG"/>
            <reg32 offset="0x21C0" name="CONFIG1" value="0x00321000" type="TE_SAMPLER_CONFIG1"/>
            <reg32 offset="0x2200" name="UNK02200" value="0x00000000"/>
            <reg32 offset="0x2240" name="UNK02240" value="0x00000000"/>
            <reg32 offset="0x2280" name="ASTC0" type="TE_SAMPLER_ASTC0"/> <!-- ASTC -->
            <reg32 offset="0x2300" name="ASTC1"/> <!-- ASTC -->
            <reg32 offset="0x2380" name="ASTC2"/> <!-- ASTC -->
            <reg32 offset="0x2340" name="ASTC3"/> <!-- ASTC -->
            <reg32 offset="0x2400" name="LOD_ADDR" length="14" stride="0x40" type="VIVM"/> <!-- Base address, per LOD level -->
            <reg32 offset="0x2C00" name="LINEAR_STRIDE" length="14" stride="0x40"> <!-- TEXTURE_LINEAR -->
                <doc>Linear stride LODn will overwrite LOD0 on GC880,GC2000. And only LOD0 is valid for this register.</doc>
            </reg32>
        </stripe>
    </stripe>

    <stripe name="NTE" brief="New texture states">
        <doc>Extra texture states for newer hardware. These exist if chipMinorFeatures2 bit 11 set.</doc>
        <stripe name="SAMPLER" length="32" stride="4">
            <doc>16 fragment texture samplers, 16 vertex texture samplers</doc>
            <reg32 offset="0x10000" name="CONFIG0" value="0x00000000" type="TE_SAMPLER_CONFIG0"/>
            <reg32 offset="0x10080" name="SIZE" value="0x00000000" type="TE_SAMPLER_SIZE"/>
            <reg32 offset="0x10100" name="LOG_SIZE" value="0x00000000" type="TE_SAMPLER_LOG_SIZE"/>
            <reg32 offset="0x10180" name="LOD_CONFIG" value="0x00000000" type="TE_SAMPLER_LOD_CONFIG"/>
            <reg32 offset="0x10200" name="UNK10200" value="0x00000000"/>
            <reg32 offset="0x10280" name="LINEAR_STRIDE" length="32"/> <!-- TEXTURE_LINEAR -->
            <reg32 offset="0x10300" name="3D_CONFIG" value="0x00000000" type="TE_SAMPLER_3D_CONFIG"/>
            <reg32 offset="0x10380" name="CONFIG1" value="0x00321000" type="TE_SAMPLER_CONFIG1"/>
            <reg32 offset="0x10400" name="UNK10400" value="0x00000000"/>
            <reg32 offset="0x10480" name="UNK10480" value="0x00000000"/>
            <reg32 offset="0x10500" name="ASTC0" type="TE_SAMPLER_ASTC0"/> <!-- ASTC -->
            <reg32 offset="0x10580" name="ASTC1"/> <!-- ASTC -->
            <reg32 offset="0x10600" name="ASTC2"/> <!-- ASTC -->
            <reg32 offset="0x10680" name="ASTC3"/> <!-- ASTC -->
            <reg32 offset="0x10700" name="BASELOD" value="0x00000F00" type="TE_SAMPLER_BASELOD"/> <!-- TEX_BASELOD -->
            <reg32 offset="0x10780" name="UNK10780" value="0x00030000"/> <!-- HALTI3 || TX_SUPPORT_DEC -->
            <reg32 offset="0x11000" name="FRAC_UNK11000"/> <!-- TX_FRAC_PRECISION_6BIT -->
            <reg32 offset="0x11080" name="FRAC_UNK11080"/> <!-- TX_FRAC_PRECISION_6BIT -->
            <reg32 offset="0x11100" name="FRAC_UNK11100"/> <!-- TX_FRAC_PRECISION_6BIT -->
            <reg32 offset="0x11180" name="FRAC_UNK11180"/> <!-- TX_FRAC_PRECISION_6BIT -->
            <reg32 offset="0x11200" name="HALTI4_UNK11200"/> <!-- HALTI4 -->
            <reg32 offset="0x11280" name="HALTI4_UNK11280"/> <!-- HALTI4 -->
            <reg32 offset="0x11300" name="FRAC_UNK11300"/> <!-- TX_FRAC_PRECISION_6BIT -->
        </stripe>
        <array offset="0x10800" name="SAMPLER_ADDR" length="32" stride="64"> <!-- Per sampler -->
            <!-- length="texBlockCount"
                 where texBlockCount=12 if chipModel == GC2000 && chipRevision == 0x5108, otherwise 32
             -->
            <reg32 offset="0" name="LOD" length="14" stride="4" type="VIVM"/> <!-- Base address, per LOD level -->
        </array>
        <reg32 offset="0x12000" name="UNK12000" value="0x00000000" length="256" stride="4"/> <!-- TX_FILTER -->
        <reg32 offset="0x12400" name="UNK12400" value="0x00000000" length="256" stride="4"/> <!-- TX_FILTER -->

        <reg32 offset="0x14C00" name="HALTI3_UNK14C00" length="16" stride="4"/> <!-- HALTI3 -->
        <reg32 offset="0x14C40" name="DESCRIPTOR_UNK14C40"> <!-- TX_DESCRIPTOR -->
            <bitfield pos="0" name="UNK0"/> <!-- Always enabled by gc7000 blob -->
        </reg32>
        <reg32 offset="0x14C44" name="DESCRIPTOR_FLUSH">
            <doc>Kernel driver writes here to flush the TX descriptor cache</doc>
            <bitfield high="31" low="28" name="UNK28"/>
        </reg32>
        <reg32 offset="0x14C48" name="DESCRIPTOR_INVALIDATE" brief="Writing here invalidates a texture descriptor"> <!-- TX_DESCRIPTOR -->
            <doc>
                This state is written, once per descriptor, when the contents of a specific descriptor have changed
                and need to be re-fetched.
            </doc>
            <bitfield low="0" high="8" name="IDX"/> <!-- Which descriptor to invalidate -->
            <bitfield pos="29" name="UNK29"/> <!-- Always set by blob -->
        </reg32>
        <stripe name="DESCRIPTOR" length="128" stride="4"> <!-- TX_DESCRIPTOR -->
            <reg32 offset="0x15800" name="ADDR_MIRROR" type="VIVM"/> <!-- MIRROR of 15C00 -->
            <reg32 offset="0x15A00" name="TX_CTRL_MIRROR"/> <!-- MIRROR of 15E00 -->
            <reg32 offset="0x15C00" name="ADDR" type="VIVM" brief="Descriptor address">
                <doc>
                    This points to a 256 byte, 64-byte aligned structure in
                    memory with the actual texture configuration.
                    See texdesc_3d.xml for the layout of texture descriptors.
                </doc>
            </reg32>
            <reg32 offset="0x15E00" name="TX_CTRL">
                <bitfield pos="0" name="TS_MODE" type="TS_MODE"/> <!-- CACHE128B256BPERLINE || SMALL_MSAA -->
                <bitfield pos="1" name="TS_ENABLE"/>
                <bitfield high="4" low="2" name="TS_INDEX" brief="Index in TS.SAMPLER[...]"/>
                <bitfield pos="5" name="COMPRESSION"/>
                <bitfield pos="6" name="128B_TILE"/> <!-- CACHE128B256BPERLINE -->
            </reg32>
            <reg32 offset="0x16000" name="SAMP_CTRL0_MIRROR"/> <!-- MIRROR of 16C00 -->
            <reg32 offset="0x16200" name="SAMP_CTRL1_MIRROR"/> <!-- MIRROR of 16E00 -->
            <reg32 offset="0x16400" name="SAMP_LOD_MINMAX_MIRROR"/> <!-- MIRROR of 17000 -->
            <reg32 offset="0x16600" name="SAMP_LOD_BIAS_MIRROR"/> <!-- MIRROR of 17200 -->
            <reg32 offset="0x16800" name="SAMP_ANISOTROPY_MIRROR"/> <!-- MIRROR of 17400 -->
            <reg32 offset="0x16C00" name="SAMP_CTRL0">
                <bitfield high="2" low="0" name="UWRAP" type="TEXTURE_WRAPMODE"/>
                <bitfield high="5" low="3" name="VWRAP" type="TEXTURE_WRAPMODE"/>
                <bitfield high="8" low="6" name="WWRAP" type="TEXTURE_WRAPMODE"/> <!-- guess -->
                <bitfield high="10" low="9" name="MIN" type="TEXTURE_FILTER" brief="Filter for minimization"/>
                <bitfield high="12" low="11" name="MIP" type="TEXTURE_FILTER" brief="Filter for filtering between mipmap levels">
                    <doc>To disable mipmapping, set this to NONE as well as set the minimum and maximum LOD level to 0..0.</doc>
                </bitfield>
                <bitfield high="14" low="13" name="MAG" type="TEXTURE_FILTER" brief="Filter for magnification"/>
                <bitfield pos="17" name="COMPARE_ENABLE"/>
                <bitfield high="20" low="18" name="COMPARE_FUNC" type="TEXTURE_COMPARE_FUNC"/>
                <bitfield pos="21" name="UNK21"/> <!-- always set? not setting this causes MMU errors -->
                <bitfield pos="22" name="UNK22"/> <!-- setting causes MMU errors -->
                <bitfield pos="23" name="INT_FILTER"/> <!-- a la TE_SAMPLER_LOG_SIZE.INT_FILTER -->
	    </reg32>
            <reg32 offset="0x16E00" name="SAMP_CTRL1">
                <!-- None of these have any, or at least much of an effect with plain 2D BGRA textures -->
                <bitfield pos="1" name="UNK1"/> <!-- always set? -->
                <bitfield pos="2" name="SRGB" brief="SRGB color space"/> <!-- a la TE_SAMPLER_LOG_SIZE.RRGB -->
                <bitfield pos="3" name="UNK3"/>
                <bitfield high="5" low="4" name="UNK4"/>
            </reg32>
            <reg32 offset="0x17000" name="SAMP_LOD_MINMAX">
                <bitfield high="15" low="0" name="MAX" type="fixedp"/>
                <bitfield high="31" low="16" name="MIN" type="fixedp"/>
            </reg32>
            <reg32 offset="0x17200" name="SAMP_LOD_BIAS">
                <bitfield high="15" low="0" name="BIAS" type="fixedp"/>
                <bitfield pos="16" name="ENABLE"/>
            </reg32>
            <reg32 offset="0x17400" name="SAMP_ANISOTROPY">
                <doc>Logarithm of size of anisotropic filter, in 8.8 format.</doc>
            </reg32>
        </stripe>
    </stripe>

    <stripe name="SH" brief="General shader unit state">
        <doc>Shader instruction memory on new hardware that supports more than 256, or more than
            1024 shader instructions (different areas are used based on these cases).</doc>
        <reg32 offset="0x15600" name="CONFIG"> <!-- HALTI5 -->
            <!-- This state replaces state 00860 on HALTI5, although it loses
                 the various flushing bits, and it's different enough to have its own bit
                 definitions.
             -->
            <bitfield pos="1" name="RTNE_ROUNDING" brief="Default rounding"/>
            <bitfield pos="2" name="DUAL16" brief="Dual-16 mode"/> <!-- Also PS.INPUT_COUNT bit 16 -->
        </reg32>
        <reg32 offset="0x20000" name="UNK20000" value="0x00000000" length="8192" stride="4"> <!-- instructionCount > 1024 -->
            <!-- length="instructionCount * 4" -->
            <!-- this unified instruction memory "needs SELECT bit to steer" according to Vivante kernel driver -->
        </reg32>
        <reg32 offset="0x0C000" name="INST_MEM" value="0x00000000" length="4096" stride="4"> <!-- 256 > instructionCount > 1024 -->
            <!-- length="instructionCount * 4" -->
            <!-- this unified instruction memory "is steered by base address" according to Vivante kernel driver,
                 which uses this range to write VS instructions
            -->
        </reg32>
        <reg32 offset="0x08000" name="INST_MEM_MIRROR" value="0x00000000" length="4096" stride="4"> <!-- 256 > instructionCount > 1024 -->
            <!-- length="instructionCount * 4" -->
            <!-- this unified instruction memory "is steered by base address" according to Vivante kernel driver,
                 which uses this range to write PS instructions
            -->
        </reg32>
        <!-- Unified uniforms area. On hardware that uses unified uniforms
             (signified by feature bit ?), both the VS and PS uniforms share this single state
             array. Their offsets are determined by VS_UNIFORM_BASE and PS_UNIFORM_BASE
             respecively. It seems to be necessary to set state 00860 to an appropriate
             value before loading these.
          -->
        <reg32 offset="0x30000" name="UNIFORMS" value="0x00000000" length="2048" stride="4">
            <!-- length="?" -->
        </reg32>
        <reg32 offset="0x34000" name="HALTI5_UNIFORMS_MIRROR" length="2048" stride="4"> <!-- HALTI5 -->
            <!-- length="?" -->
        </reg32>
        <reg32 offset="0x36000" name="HALTI5_UNIFORMS" length="2048" stride="4"> <!-- HALTI5 -->
            <!-- length="?" -->
        </reg32>
    </stripe>
</domain>

</database>

